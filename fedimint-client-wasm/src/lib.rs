#![cfg(target_family = "wasm")]
mod db;

use std::pin::pin;
use std::str::FromStr;
use std::sync::Arc;

use async_stream::try_stream;
use db::MemAndIndexedDb;
use fedimint_client::ClientHandleArc;
use fedimint_client::secret::{PlainRootSecretStrategy, RootSecretStrategy};
use fedimint_client_module::module::IClientModule;
use fedimint_core::db::Database;
use fedimint_core::invite_code::InviteCode;
use fedimint_ln_client::{LightningClientInit, LightningClientModule};
use fedimint_mint_client::MintClientInit;
use futures::StreamExt;
use futures::future::{AbortHandle, Abortable};
use lightning_invoice::{Bolt11Invoice, Bolt11InvoiceDescription};
use serde_json::json;
use wasm_bindgen::prelude::wasm_bindgen;
use wasm_bindgen::{JsError, JsValue};

#[wasm_bindgen]
pub struct WasmClient {
    client: ClientHandleArc,
}

#[wasm_bindgen]
pub struct RpcHandle {
    abort_handle: AbortHandle,
}

#[wasm_bindgen]
impl RpcHandle {
    #[wasm_bindgen]
    pub fn cancel(&self) {
        self.abort_handle.abort();
    }
}

#[wasm_bindgen]
impl WasmClient {
    #[wasm_bindgen]
    /// Open fedimint client with already joined federation.
    ///
    /// After you have joined a federation, you can reopen the fedimint client
    /// with same client_name. Opening client with same name at same time is
    /// not supported. You can close the current client by calling
    /// `client.free()`. NOTE: The client will remain active until all the
    /// running rpc calls have finished.
    // WasmClient::free is auto generated by wasm bindgen.
    pub async fn open(client_name: String) -> Result<Option<WasmClient>, JsError> {
        Self::open_inner(client_name)
            .await
            .map_err(|x| JsError::new(&x.to_string()))
    }

    #[wasm_bindgen]
    /// Open a fedimint client by join a federation.
    pub async fn join_federation(
        client_name: String,
        invite_code: String,
    ) -> Result<WasmClient, JsError> {
        Self::join_federation_inner(client_name, invite_code)
            .await
            .map_err(|x| JsError::new(&x.to_string()))
    }

    #[wasm_bindgen]
    /// Parse an invite code and extract its components without joining the
    /// federation
    pub fn parse_invite_code(invite_code: &str) -> Result<String, JsError> {
        let invite_code =
            InviteCode::from_str(&invite_code).map_err(|e| JsError::new(&e.to_string()))?;
        let federation_id = invite_code.federation_id().to_string();
        let url = invite_code.url().to_string();
        let result = json!({
            "url": url,
            "federation_id": federation_id,
        });
        Ok(serde_json::to_string(&result).map_err(|e| JsError::new(&e.to_string()))?)
    }

    #[wasm_bindgen]
    /// Parse a bolt11 invoice and extract its components
    /// without joining the federation
    pub fn parse_bolt11_invoice(invoice_str: &str) -> Result<String, JsError> {
        let invoice = lightning_invoice::Bolt11Invoice::from_str(invoice_str)
            .map_err(|e| JsError::new(&format!("Failed to parse Lightning invoice: {}", e)))?;

        let amount_msat = invoice.amount_milli_satoshis().unwrap_or(0);
        let amount_sat = amount_msat as f64 / 1000.0;

        let expiry_seconds = invoice.expiry_time().as_secs();

        // memo
        let description = match invoice.description() {
            Bolt11InvoiceDescription::Direct(desc) => desc.to_string(),
            Bolt11InvoiceDescription::Hash(_) => "Description hash only".to_string(),
        };

        let response = json!({
            "amount": amount_sat,
            "expiry": expiry_seconds,
            "memo": description,
        });
        Ok(serde_json::to_string(&response).map_err(|e| JsError::new(&e.to_string()))?)
    }

    #[wasm_bindgen]
    /// Preview a federation by its invite code without joining it
    /// Returns federation information including config, federation ID, and other metadata
    pub async fn preview_federation(invite_code: &str) -> Result<String, JsError> {
        Self::preview_federation_inner(invite_code)
            .await
            .map_err(|e| JsError::new(&e.to_string()))
    }

    async fn client_builder(db: Database) -> Result<fedimint_client::ClientBuilder, anyhow::Error> {
        let mut builder = fedimint_client::Client::builder(db).await?;
        builder.with_module(MintClientInit);
        builder.with_module(LightningClientInit::default());
        // FIXME: wallet module?
        builder.with_primary_module(1);
        Ok(builder)
    }

    async fn open_inner(client_name: String) -> anyhow::Result<Option<WasmClient>> {
        let db = Database::from(MemAndIndexedDb::new(&client_name).await?);
        if !fedimint_client::Client::is_initialized(&db).await {
            return Ok(None);
        }
        let client_secret = fedimint_client::Client::load_or_generate_client_secret(&db).await?;
        let root_secret = PlainRootSecretStrategy::to_root_secret(&client_secret);
        let builder = Self::client_builder(db).await?;
        Ok(Some(Self {
            client: Arc::new(builder.open(root_secret).await?),
        }))
    }

    async fn join_federation_inner(
        client_name: String,
        invite_code: String,
    ) -> anyhow::Result<WasmClient> {
        let db = Database::from(MemAndIndexedDb::new(&client_name).await?);
        let client_secret = fedimint_client::Client::load_or_generate_client_secret(&db).await?;
        let root_secret = PlainRootSecretStrategy::to_root_secret(&client_secret);
        let builder = Self::client_builder(db).await?;
        let invite_code = InviteCode::from_str(&invite_code)?;
        let config = fedimint_api_client::api::net::Connector::default()
            .download_from_invite_code(&invite_code)
            .await?;
        let client = Arc::new(builder.join(root_secret, config, None).await?);
        Ok(Self { client })
    }

    #[wasm_bindgen]
    /// Call a fedimint client rpc the responses are returned using `cb`
    /// callback. Each rpc call *can* return multiple responses by calling
    /// `cb` multiple times. The returned RpcHandle can be used to cancel the
    /// operation.
    pub fn rpc(
        &self,
        module: &str,
        method: &str,
        payload: String,
        cb: &js_sys::Function,
    ) -> RpcHandle {
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        let rpc_handle = RpcHandle { abort_handle };

        let client = self.client.clone();
        let module = module.to_string();
        let method = method.to_string();
        let cb = cb.clone();

        wasm_bindgen_futures::spawn_local(async move {
            let future = async {
                let mut stream = pin!(Self::rpc_inner(&client, &module, &method, payload));

                while let Some(item) = stream.next().await {
                    let this = JsValue::null();
                    let _ = match item {
                        Ok(item) => cb.call1(
                            &this,
                            &JsValue::from_str(
                                &serde_json::to_string(&json!({"data": item})).unwrap(),
                            ),
                        ),
                        Err(err) => cb.call1(
                            &this,
                            &JsValue::from_str(
                                &serde_json::to_string(&json!({"error": err.to_string()})).unwrap(),
                            ),
                        ),
                    };
                }

                // Send the end message
                let _ = cb.call1(
                    &JsValue::null(),
                    &JsValue::from_str(&serde_json::to_string(&json!({"end": null})).unwrap()),
                );
            };

            let abortable_future = Abortable::new(future, abort_registration);
            let _ = abortable_future.await;
        });

        rpc_handle
    }
    fn rpc_inner<'a>(
        client: &'a ClientHandleArc,
        module: &'a str,
        method: &'a str,
        payload: String,
    ) -> impl futures::Stream<Item = anyhow::Result<serde_json::Value>> + 'a {
        async_stream::stream! {
            // Parse the payload
            let payload_result = serde_json::from_str::<serde_json::Value>(&payload);
            if let Err(e) = payload_result {
                yield Err(anyhow::format_err!("Failed to parse payload: {}", e));
                return;
            }
            let payload = payload_result.unwrap();

            match module {
                "" => {
                    if method == "preview_federation" {
                        // Extract invite code
                        let invite_code = match payload.get("invite_code").and_then(|v| v.as_str()) {
                            Some(code) => code,
                            None => {
                                yield Err(anyhow::format_err!("Missing or invalid invite_code parameter"));
                                return;
                            }
                        };
                        
                        // Parse invite code
                        let invite_code = match InviteCode::from_str(invite_code) {
                            Ok(code) => code,
                            Err(e) => {
                                yield Err(anyhow::format_err!("Invalid invite code: {}", e));
                                return;
                            }
                        };
                        
                        // Download config
                        let connector = fedimint_api_client::api::net::Connector::default();
                        let config = match connector.download_from_invite_code(&invite_code).await {
                            Ok(config) => config,
                            Err(e) => {
                                yield Err(anyhow::format_err!("Failed to download federation config: {}", e));
                                return;
                            }
                        };
                        
                        // Extract federation ID
                        let federation_id = invite_code.federation_id().to_string();
                        
                        // Extract endpoints
                        let endpoints = config.global.api_endpoints.iter()
                            .map(|(_, url)| url.url.to_string())
                            .collect::<Vec<String>>();
                        
                        // Extract metadata
                        let metadata = match config.meta::<serde_json::Value>("metadata") {
                            Ok(Some(meta)) => meta,
                            Ok(None) => serde_json::json!({}),
                            Err(_) => serde_json::json!({}),
                        };
                        
                        // Serialize config
                        let config_value = match serde_json::to_value(&config) {
                            Ok(value) => value,
                            Err(e) => {
                                yield Err(anyhow::format_err!("Failed to serialize config: {}", e));
                                return;
                            }
                        };
                        
                        // Create response
                        let response = json!({
                            "config": config_value,
                            "federationId": federation_id,
                            "endpoints": endpoints,
                            "metadata": metadata,
                        });
                        
                        yield Ok(response);
                    } else {
                        let mut stream = client.handle_global_rpc(method.to_owned(), payload);
                        while let Some(item) = stream.next().await {
                            yield item;
                        }
                    }
                }
                "ln" => {
                    match client.get_first_module::<LightningClientModule>() {
                        Ok(ln) => {
                            let mut stream = ln.inner().handle_rpc(method.to_owned(), payload).await;
                            while let Some(item) = stream.next().await {
                                yield item;
                            }
                        },
                        Err(e) => {
                            yield Err(anyhow::format_err!("Failed to get lightning module: {}", e));
                        }
                    }
                }
                "mint" => {
                    match client.get_first_module::<fedimint_mint_client::MintClientModule>() {
                        Ok(mint) => {
                            let mut stream = mint.inner().handle_rpc(method.to_owned(), payload).await;
                            while let Some(item) = stream.next().await {
                                yield item;
                            }
                        },
                        Err(e) => {
                            yield Err(anyhow::format_err!("Failed to get mint module: {}", e));
                        }
                    }
                }
                _ => {
                    yield Err(anyhow::format_err!("Module not found: {}", module));
                },
            }
        }
    }

    async fn preview_federation_inner(invite_code: &str) -> anyhow::Result<String> {
        let invite_code = InviteCode::from_str(invite_code)?;
        let connector = fedimint_api_client::api::net::Connector::default();
        
        // Download the configuration from the invite code
        let config = connector.download_from_invite_code(&invite_code).await?;
        
        // Extract federation ID
        let federation_id = invite_code.federation_id().to_string();
        
        // Extract endpoints
        let endpoints = config.global.api_endpoints.iter()
            .map(|(_, url)| url.url.to_string())
            .collect::<Vec<String>>();
        
        // Extract metadata - fix: handle Option correctly
        let metadata = match config.meta::<serde_json::Value>("metadata") {
            Ok(Some(meta)) => meta,
            Ok(None) => serde_json::json!({}),
            Err(_) => serde_json::json!({}),
        };
        
        // Create response JSON
        let config_value = serde_json::to_value(&config)
            .map_err(|e| anyhow::format_err!("Failed to serialize config: {}", e))?;
        
        let response = json!({
            "config": config_value,
            "federationId": federation_id,
            "endpoints": endpoints,
            "metadata": metadata,
        });
        
        Ok(serde_json::to_string(&response)?)
    }

     fn handle_global_rpc_preview_federation(
        invite_code: &str,
    ) -> anyhow::Result<serde_json::Value> {
        let invite_code = InviteCode::from_str(invite_code)?;
        let federation_id = invite_code.federation_id().to_string();
        let url = invite_code.url().to_string();
        
        Ok(json!({
            "federationId": federation_id,
            "url": url,
        }))
    }
}
