use std::collections::{BTreeMap, HashMap};
use std::hash::Hash;

use async_trait::async_trait;
use fedimint_api::db::Database;
use fedimint_api::encoding::{Decodable, Encodable};
use fedimint_api::module::FederationModule;
use fedimint_api::tiered::InvalidAmountTierError;
use fedimint_api::{Amount, OutPoint, PeerId, Tiered, TieredMulti};
use serde::{Deserialize, Serialize};
use tbs::{AggregatePublicKey, PublicKeyShare, SecretKeyShare};
use thiserror::Error;
use tracing::error;

pub mod config;

mod db;
/// Data structures taking into account different amount tiers

/// Federated mint member mint
#[allow(dead_code)]
pub struct Mint {
    sec_key: Tiered<SecretKeyShare>,
    pub_key_shares: BTreeMap<PeerId, Tiered<PublicKeyShare>>,
    pub_key: HashMap<Amount, AggregatePublicKey>,
    db: Database,
}

#[derive(Debug, Clone, Eq, PartialEq, Hash, Serialize, Deserialize, Encodable, Decodable)]
pub struct PartiallySignedRequest {
    pub out_point: OutPoint,
    pub partial_signature: PartialSigResponse,
}

/// Request to blind sign a certain amount of coins
#[derive(Debug, Clone, Eq, PartialEq, Hash, Deserialize, Serialize, Encodable, Decodable)]
pub struct SignRequest(pub TieredMulti<tbs::BlindedMessage>);

// FIXME: optimize out blinded msg by making the mint remember it
/// Blind signature share for a [`SignRequest`]
#[derive(Debug, Clone, Eq, PartialEq, Hash, Deserialize, Serialize, Encodable, Decodable)]
pub struct PartialSigResponse(pub TieredMulti<(tbs::BlindedMessage, tbs::BlindedSignatureShare)>);

/// Blind signature for a [`SignRequest`]
#[derive(Debug, Clone, Eq, PartialEq, Hash, Deserialize, Serialize, Encodable, Decodable)]
pub struct SigResponse(pub TieredMulti<tbs::BlindedSignature>);

/// An verifiable one time use IOU from the mint.
///
/// Digital version of a "note of deposit" in a free-banking era.
///
/// Consist of a user-generated nonce and a threshold signature over it generated by the
/// federated mint (while in a [`BlindNonce`] form).
///
/// As things are right now the denomination of each note is deteremined by the federation
/// keys that signed over it, and needs to be tracked outside of this type.
///
/// In this form it can only be validated, not spent since for that the corresponding secret
/// spend key is required.
#[derive(Debug, Clone, Eq, PartialEq, Hash, Deserialize, Serialize, Encodable, Decodable)]
pub struct Note(pub Nonce, pub tbs::Signature);

/// Unique ID of a mint note.
///
/// User-generated, random or otherwise unpredictably generated (deterministically derivated).
///
/// Internally a MuSig pub key so that transactions can be signed when being spent.
#[derive(Debug, Clone, Eq, PartialEq, Hash, Deserialize, Serialize, Encodable, Decodable)]
pub struct Nonce(pub secp256k1_zkp::XOnlyPublicKey);

/// [`Nonce`] but blinded by the user key
///
/// Blinding prevents the Mint from being able to link the transaction spending [`Note`]s
/// as an `Input`s of `Transaction` with new [`Note`]s being created in its `Output`s.
///
/// By signing it, the mint commits to the underlying (unblinded) [`Nonce`] as valid
/// (until eventually spent).
#[derive(Debug, Clone, Eq, PartialEq, Hash, Deserialize, Serialize, Encodable, Decodable)]
pub struct BlindNonce(pub tbs::BlindedMessage);

#[async_trait(?Send)]
impl FederationModule for Mint {
    type TxInput = TieredMulti<Note>;
    type TxOutput = TieredMulti<BlindNonce>;
    type TxOutputOutcome = Option<SigResponse>; // TODO: make newtype
}

impl Note {
    /// Verify the coin's validity under a mit key `pk`
    pub fn verify(&self, pk: tbs::AggregatePublicKey) -> bool {
        tbs::verify(self.0.to_message(), self.1, pk)
    }

    /// Access the nonce as the public key to the spend key
    pub fn spend_key(&self) -> &secp256k1_zkp::XOnlyPublicKey {
        &self.0 .0
    }
}

impl Nonce {
    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = vec![];
        bincode::serialize_into(&mut bytes, &self.0).unwrap();
        bytes
    }

    pub fn from_bytes(bytes: &[u8]) -> Self {
        // FIXME: handle errors or the client can be crashed
        bincode::deserialize(bytes).unwrap()
    }

    pub fn to_message(&self) -> tbs::Message {
        tbs::Message::from_bytes(&self.0.serialize()[..])
    }
}

impl From<SignRequest> for TieredMulti<BlindNonce> {
    fn from(sig_req: SignRequest) -> Self {
        sig_req
            .0
            .into_iter()
            .map(|(amt, token)| (amt, crate::BlindNonce(token)))
            .collect()
    }
}

/// Represents an array of mint indexes that delivered faulty shares
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub struct MintShareErrors(pub Vec<(PeerId, PeerErrorType)>);

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum PeerErrorType {
    InvalidSignature,
    DifferentStructureSigShare,
    DifferentNonce,
    InvalidAmountTier,
}

#[derive(Debug, Clone, Eq, PartialEq, Hash, Error)]
pub enum CombineError {
    #[error("Too few shares to begin the combination: got {0:?} need {1}")]
    TooFewShares(Vec<PeerId>, usize),
    #[error(
        "Too few valid shares, only {0} of {1} (required minimum {2}) provided shares were valid"
    )]
    TooFewValidShares(usize, usize, usize),
    #[error("We could not find our own contribution in the provided shares, so we have no validation reference")]
    NoOwnContribution,
    #[error("Peer {0} contributed {1} shares, 1 expected")]
    MultiplePeerContributions(PeerId, usize),
}

#[derive(Debug, Clone, Eq, PartialEq, Hash, Error)]
pub enum MintError {
    #[error("One of the supplied coins had an invalid mint signature")]
    InvalidCoin,
    #[error("Insufficient coin value: reissuing {0} but only got {1} in coins")]
    TooFewCoins(Amount, Amount),
    #[error("One of the supplied coins was already spent previously")]
    SpentCoin,
    #[error("One of the coins had an invalid amount not issued by the mint: {0:?}")]
    InvalidAmountTier(Amount),
    #[error("One of the coins had an invalid signature")]
    InvalidSignature,
}

impl From<InvalidAmountTierError> for MintError {
    fn from(e: InvalidAmountTierError) -> Self {
        MintError::InvalidAmountTier(e.0)
    }
}
