<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module implements fedimints custom atomic broadcast abstraction. A such, it is responsible for ordering serialized items in the form of byte vectors. The Broadcast is able to recover from a crash at any time via a backup that it maintains in the servers fedimint_core::db::Database. In Addition, it stores the history of accepted items in the form of signed blocks in the database as well in order to catch up fellow guardians which have been offline for a prolonged period of time."><title>fedimint_server::atomic_broadcast - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="fedimint_server" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0 (cc66ad468 2023-10-03)" data-channel="1.73.0" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-1596385f77d47ef2.css" data-theme-dark-css="dark-0a43001d3fc2282c.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-1596385f77d47ef2.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-0a43001d3fc2282c.css"><link rel="stylesheet" href="../../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../fedimint_server/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../fedimint_server/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module atomic_broadcast</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">fedimint_server</a>::<wbr><a class="mod" href="#">atomic_broadcast</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/fedimint_server/atomic_broadcast/mod.rs.html#1-120">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module implements fedimints custom atomic broadcast abstraction. A
such, it is responsible for ordering serialized items in the form of byte
vectors. The Broadcast is able to recover from a crash at any time via a
backup that it maintains in the servers <a href="../../fedimint_core/db/struct.Database.html" title="struct fedimint_core::db::Database">fedimint_core::db::Database</a>. In
Addition, it stores the history of accepted items in the form of
signed blocks in the database as well in order to catch up fellow guardians
which have been offline for a prolonged period of time.</p>
<p>Though the broadcast depends on <a href="../../fedimint_core/index.html" title="mod fedimint_core">fedimint_core</a> for <a href="../../fedimint_core/struct.PeerId.html" title="struct fedimint_core::PeerId">fedimint_core::PeerId</a>,
<a href="../../fedimint_core/encoding/trait.Encodable.html" title="trait fedimint_core::encoding::Encodable">fedimint_core::encoding::Encodable</a> and <a href="../../fedimint_core/db/struct.Database.html" title="struct fedimint_core::db::Database">fedimint_core::db::Database</a>
it implements no consensus logic specific to Fedimint, to which we will
refer as Fedimint Consensus going forward. To the broadcast a consensus item
is merely a vector of bytes without any further structure.</p>
<h2 id="the-journey-of-a-consensusitem"><a href="#the-journey-of-a-consensusitem">The journey of a ConsensusItem</a></h2>
<p>Let us sketch the journey of an <a href="../../fedimint_core/epoch/enum.ConsensusItem.html" title="enum fedimint_core::epoch::ConsensusItem">fedimint_core::epoch::ConsensusItem</a> into a
signed block.</p>
<ul>
<li>The node which wants to order the item calls consensus_encode to serialize
it and sends the resulting serialization to its running atomic broadcast
instance via the mempool item sender.</li>
<li>Every 250ms the broadcasts currently running session instance creates a
new batch from its mempool and attaches it to a unit in the form of a
UnitData::Batch. The size of a batch and therefore the size of a
serialization is limited to 10kB.</li>
<li>The unit is then included in a <a href="struct.Message.html" title="struct fedimint_server::atomic_broadcast::Message">Message</a> and send to the network layer via
the outgoing message sender.</li>
<li>The network layer receives the message, serializes it via consensus_encode
and sends it to its peers, which in turn deserialize it via
consensus_decode and relay it to their broadcast instance via their
incoming message sender.</li>
<li>The unit is added to the local subgraph of a common directed acyclic graph
of units generated cooperatively by all peers for every session.</li>
<li>As the local subgraph grows the units within it are ordered and so are the
attached batches. As soon as it is ordered the broadcast instances unpacks
our batch sends the serialization to Fedimint Consensus in the form of an
ordered item.</li>
<li>Fedimint Consensus then deserializes the item and either accepts the item
bases on its current consensus state or discards it otherwise. Fedimint
Consensus transmits its decision to its broadcast instance via the
decision_sender and processes the next item.</li>
<li>Assuming our item has been accepted the broadcast instance appends its
deserialization is added to the block corresponding to the current
session.</li>
<li>Roughly every five minutes the session completes. Then the broadcast
creates a threshold signature for the blocks header and saves both in the
form of a signed block in the local database.</li>
</ul>
<h2 id="interplay-with-fedimint-consensus"><a href="#interplay-with-fedimint-consensus">Interplay with Fedimint Consensus</a></h2>
<p>As an item is only recorded in a block if it has been accepted the decision
has to be consisted for all correct nodes in order for them to create
identical blocks for every session. We introduce this complexity in order to
prevent a critical DOS vector were a client submits conflicting items, like
double spending an ecash note for example, to different peers. If Fedimint
Consensus would not be able to discard the conflicting items in such a way
that they do not become part of the broadcasts history all of those items
would need to be maintained on disk indefinitely.</p>
<p>Therefore it cannot be guaranteed that all broadcast instances return the
exact stream of ordered items. However, if two correct peers obtain two
ordered items from their broadcast instances they are guaranteed to be in
the same order. Furthermore, an ordered items is guaranteed to be seen by
all correct nodes if a correct peer accepts it. Those two guarantees are
sufficient to build consistent replicated state machines like Fedimint
Consensus on top of the broadcast. Such a state machine has to accept an
item if it changes the machines state and should discard it otherwise. Let
us consider the case of an ecash note being double spend by the items
A and B while one peer is offline. First, item A is ordered and all correct
peers include the note as spent in their state. Therefore they also accept
the item A. Then, item B is ordered and all correct nodes notice the double
spend and make no changes to their state. Now they can safely discard the
item B as it did not cause a state transition. When the session completes
only item A is part of the corresponding block. When the offline peer comes
back online it downloads the block. Therefore the recovering peer will only
see Item A but arrives at the same state as its peers at the end of the
session regardless. However, it did so by processing one less ordered item
and without realizing that a double spend had occurred.</p>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.Keychain"><code>pub use keychain::<a class="struct" href="keychain/struct.Keychain.html" title="struct fedimint_server::atomic_broadcast::keychain::Keychain">Keychain</a>;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="backup/index.html" title="mod fedimint_server::atomic_broadcast::backup">backup</a></div></li><li><div class="item-name"><a class="mod" href="data_provider/index.html" title="mod fedimint_server::atomic_broadcast::data_provider">data_provider</a></div></li><li><div class="item-name"><a class="mod" href="finalization_handler/index.html" title="mod fedimint_server::atomic_broadcast::finalization_handler">finalization_handler</a></div></li><li><div class="item-name"><a class="mod" href="keychain/index.html" title="mod fedimint_server::atomic_broadcast::keychain">keychain</a></div></li><li><div class="item-name"><a class="mod" href="network/index.html" title="mod fedimint_server::atomic_broadcast::network">network</a></div></li><li><div class="item-name"><a class="mod" href="spawner/index.html" title="mod fedimint_server::atomic_broadcast::spawner">spawner</a></div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Message.html" title="struct fedimint_server::atomic_broadcast::Message">Message</a></div><div class="desc docblock-short">The majority of these messages need to be delivered to the intended
<a href="enum.Recipient.html" title="enum fedimint_server::atomic_broadcast::Recipient">Recipient</a> in order for the broadcast to make progress. However, the
broadcast does not assume a reliable network layer and implements all
necessary retry logic. Therefore, the caller can discard a message
immediately if its intended recipient is offline.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Recipient.html" title="enum fedimint_server::atomic_broadcast::Recipient">Recipient</a></div><div class="desc docblock-short">This enum defines the intended destination of a <a href="struct.Message.html" title="struct fedimint_server::atomic_broadcast::Message">Message</a>.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.to_node_index.html" title="fn fedimint_server::atomic_broadcast::to_node_index">to_node_index</a></div></li><li><div class="item-name"><a class="fn" href="fn.to_peer_id.html" title="fn fedimint_server::atomic_broadcast::to_peer_id">to_peer_id</a></div></li></ul></section></div></main></body></html>